RISHAB RAMANATHAN
19-558
CSE 2
TEAM 46

The two questions are implemented in two scripts.

1] huffman.c

Compilation:    gcc huffman.c -o huffman -lm
Execution:      ./huff <choice for decoding file>

In the choice, the values are 0 for no, 1 for yes.

The program can be looked at in 5 parts

-Frequency table generation:
    The Frequency table is generated by reading every character and appending new symbols into an array. If the symbol is already in the array,
    the corresponding tally is incremented.

-Huffman tree:
    The symbols and their frequencies are implemented into a list, where each list contains a binary tree. Huffman's algorithm is implemented
    for each iteration, until the list contains only one element, and that element contains the huffman tree.

-Huffman code:
    The huffman tree is then traversed to get the corresponding binary code for every symbol. It's a recursive function which appends a 0 and
    calls the function for the left tree, and appends a 1 and calls the right subtree, for every node. The base case is when a leaf is reached,
    at which point the binary number generated is added to the code array.

-Binary encoding:
    Since binary files are written in bytes, this could not be done with a straightforward function. The logic used was to create an unsigned
    char buffer variable (1 byte size) and add the binary encoding to the buffer. Every time the capacity of the buffer is filled, the variable
    is written to the binary file and the buffer is emptied. In case of partial code write, the remaining code will be written in the next
    buffer write. In case of the final symbol encoding, in the case of the buffer not being filled up to 8 bits, the buffer will be left
    shifted until the most significant bit is the start of the code, which is then written.

-Decoding:
    An unsigned char buffer is used to read the data from the binary file. The bits in the buffer is used to traverse the huffman tree generated
    using 0 as left subtree and 1 as right subtree. When a leaf node is encountered, the symbol is written to the output file and the traversal
    is reset. The final byte and number of used bits in final byte is recorded from the binary encoding, to make sure no garbage bits are 
    decoded.

2] sssp.c

Compilation:    gcc sssp.c -o sssp
Execution:      ./sssp <number of vertices> <adjacency matrix>

In adjacency matrix, for any pair of vertices not connected, use 0 as weight.

Function description:

minDistance():
returns the vertex with the minimum distance, from the set of vertices not part of the minimum spanning tree.

ssp():
Generates the set of shortest paths from a source vertex. This is achieved by first getting two arrays for distance from source, and an array
to keep track of the vertices part of the minimum spanning tree.
The script starts from the source, and updates the distance of all adjacent vertices with the minimum path length. From the adjacent vertices
it chooses the minimum path vertext, and iterates. This is done until every vertex is part of the mst.